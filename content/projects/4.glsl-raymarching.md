---
title: "GLSL Sphere Marching"
thumbnail: "/images/projects/sphere-marching/thumbnail.webp"
description: "This project uses a graphics programming technique called sphere marching with custom-made distance functions."
technologies: ["ThreeJS", "GLSL"]
assets: "/images/projects/sphere-marching"
showcased: true
---

# {{title}}

## Project Description
In this specific implementation, I focus on rendering spheres using ray marching and custom distance functions. I also found this cool technique called smooth blending to create smooth transitions between the spheres. This allows for more visually interesting and complex shape that would typically be difficult to make.

## Technologies Used

<BlogTechnologies :tags="technologies"></BlogTechnologies>

## Vertex Shader

The vertex shader is simply a pass through shader as it's the fragment shader that does all the magic.

```glsl
out vec2 v_Uv;

void main() {
  v_Uv = uv;
  gl_Position = vec4(position, 1.0);
}
```

## Fragment Shader

The fragment shader is responsible for rendering this scene. In our case, it will be calculating the color based on ray marching and signed distance functions.

We first need to represent the scene using data structures.

```glsl
struct Shape {
  vec3 position;
  vec3 size;
  vec4 color;
};

struct SceneInfo {
  vec3 color;
  vec4 normal;
  float distance;
};

struct Ray {
  vec3 origin;
  vec3 direction;
};
```

Next we need to define our signed distance function. For a sphere, it is simply the distance from the eye to the center subtracted by the radius of the sphere.

```glsl
float sphereDistance(vec3 eye, vec3 center, float radius) {
  return distance(eye, center) - radius;
}
```

I've also come across this smooth blend function while researching this project and essentially it produces a smooth continuous surface where two surfaces intersect.

```glsl
vec4 smoothBlend(float a, float b, vec3 colA, vec3 colB, float k) {
  float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
  float blendDst = mix(b, a, h) - k * h * (1.0 - h);
  vec3 blendCol = mix(colB, colA, h);
  return vec4(blendCol, blendDst);
}

float smoothBlendDist(float a, float b, float k) {
  float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
  return mix(b, a, h) - k * h * (1.0 - h);
}
```

I made this 

```glsl
SceneInfo getRaySceneInfo(vec3 origin) {
  SceneInfo info;
  info.distance = 100000000.0;
  info.color = vec3(1.0);
  for(int i = 0; i < NUM_SHAPES; i++) {
    vec4 b = smoothBlend(info.distance, getShapeDist(origin, shapes[i]), info.color.xyz, shapes[i].color.xyz, 2.0);
    info.distance = b.w;
    info.color = b.xyz;
  }
  return info;
}
```

```glsl
vec3 estimateNormal(vec3 p) {
  float x = getSceneDist(vec3(p.x + epsilonNorm, p.y, p.z)) - getSceneDist(vec3(p.x - epsilonNorm, p.y, p.z));
  float y = getSceneDist(vec3(p.x, p.y + epsilonNorm, p.z)) - getSceneDist(vec3(p.x, p.y - epsilonNorm, p.z));
  float z = getSceneDist(vec3(p.x, p.y, p.z + epsilonNorm)) - getSceneDist(vec3(p.x, p.y, p.z - epsilonNorm));
  return normalize(vec3(x, y, z));
}
```



```glsl
void main() {
  shapes = Shape[NUM_SHAPES](...);
  vec2 uv = gl_FragCoord.xy / vec2(u_WindowWidth, u_WindowHeight) * 2.0 - 1.0; //(NDC)
  Ray ray = createRayFromCamera(uv);

  float totalMarchedDist = 0.0;
  f_Color = vec4(0.0, 0.0, 0.0, 1.0);
  int marchedSteps = 0;

  // We want to keep marching until we reach the maximium amount of steps
  while(marchedSteps < MAX_STEP_COUNT) {
    float deltaDistMarched;
    // Calulate the distance to the scene
    deltaDistMarched = getSceneDist(ray.origin);
    // March the ray
    ray.origin += ray.direction * deltaDistMarched;
    totalMarchedDist += deltaDistMarched;
    marchedSteps++;
    
    // If we've marched too far, no intersection
    if (totalMarchedDist > MAX_DISTANCE) {
      f_Color = vec4(0,0,0, 1.0);
      return;
    }
    // If very close to a surface, we've found an intersection
    if(deltaDistMarched <= epsilon) {
      break;
    }
  }

  // Check if our ray is withing a small distance epsilon to the scene then we perform all the expensive calculations.
  if(deltaDistMarched <= epsilon) {
    SceneInfo info = getRaySceneInfo(ray.origin);
    vec3 normal = estimateNormal(ray.origin);
    vec3 color = getColor(info.color, ray.origin, normal);
    f_Color = vec4(color, 1.0);
  }
}
```

## Results
