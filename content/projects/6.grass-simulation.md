---
title: "Grass Simulation"
thumbnail: "/images/projects/grass/thumbnail.webp"
description: "Grass simulation done in unity using, tessellation and geometry shaders. The grass' appearance is inspired by Hoyoverse's Genshin Impact."
technologies: ["Unity URP", "HLSL", "C#"]
assets: "/images/projects/grass"
github: "https://github.com/WeichenTie/12-Unity-Grass-Shader"
showcased: true
---

# {{title}}

<view-github-button :to="github"></view-github-button>

## Project Description

Throughout late 2020 and 2021, I was heavily invested in a ARPG game called Genshin Impact. One thing that I found really beautiful was the grassy terrain that was present throughout the game so I became really inspired to recreate this effect and hence this project. Although I know that using geometry and tessellation shaders may not have been the best approach, I kind of wanted to have an excuse to learn them while having fun.

## Technologies Used

<BlogTechnologies :tags="technologies"></BlogTechnologies>

## Vertex Shader

```hlsl
VertexOut vertexShader (VertexIn vertIn) {
  VertexOut vertOut;
  vertOut.position = vertIn.position;
  return vertOut;
}
```

## Patch Constant Function

```hlsl
TessellationFactors patchConstantFunction(InputPatch<VertexOut, 3> patch) {
  //UNITY_SETUP_INSTANCE_ID(patch[0]);
  TessellationFactors f;
  f.edge[0] = 1;
  f.edge[1] = 1;
  f.edge[2] = 1;

  if (distance(_PlayerPosition, patch[0].position) > 70 && // [!code highlight]
    distance(_PlayerPosition, patch[1].position) > 70 && // [!code highlight]
    distance(_PlayerPosition, patch[2].position) > 70 // [!code highlight]
  ) {
    f.edge[0] = 0;
  }
  f.inside = 20;
  return f;
}
```

```hlsl
[domain("tri")]
[outputcontrolpoints(3)]
[outputtopology("triangle_ccw")]
[patchconstantfunc("patchConstantFunction")]
[partitioning("integer")]
VertexOut hullShader(
  InputPatch<VertexOut, 3> patch,
  uint id: SV_OutputControlPointID)
{
  return patch[id];
}
```

## Domain Shader

```hlsl
#define BARYCENTRIC_INTERPOLATE(fieldName) \
  patch[0].fieldName * barycentricCoords.x + \
  patch[1].fieldName * barycentricCoords.y + \
  patch[2].fieldName * barycentricCoords.z

[domain("tri")]
DomainOut domainShader(
  TessellationFactors factors,
  OutputPatch<VertexOut, 3> patch,
  float3 barycentricCoords: SV_DomainLocation
) {
  DomainOut output;

  output.position = BARYCENTRIC_INTERPOLATE(position);
  output.normal = normalFrom3Points(patch[0].position.xyz, patch[1].position.xyz, patch[2].position.xyz);

  return output;
}
```

## Geometry Shader

```hlsl
[maxvertexcount(11)]
void geometryShader (triangle DomainOut inputs[3], inout TriangleStream<GeometryOut> outputStream)
{
  float _NUM_SEGMENTS = 4.0;
  float _MAX_BLADE_LENGTH = 1.0;
  float _MIN_BLADE_LENGTH = 0.4;

  for (int i = 0; i < 3; i++) {
    float3 position = inputs[i].position.xyz;
    float3 normal = inputs[i].normal;
    float rand1 = rand(position.xz);
    float rand2 = rand(float2(rand1, position.x));

    float3x3 rotationMatrix = getRotationMatrix(rand1 * 360);
    float3 grassFwdDir = mul(rotationMatrix, float3(0, 0, 1));

    float fullBladeLength = lerp(_MIN_BLADE_LENGTH, _MAX_BLADE_LENGTH, rand1);
    // Calculate blade length;
    float3 root = position;
    for (float i = 0.0; i < _NUM_SEGMENTS; i+=1.0) {
      float fullLengthPercent = i / _NUM_SEGMENTS;
      float segmentLength = fullLengthPercent * fullBladeLength;
      float halfWidth = calcBladeHalfWidth(fullLengthPercent);
      // Grass Generation
      float3 bladeSegment = calcSegmentVector(position, normal, rotationMatrix, segmentLength, fullLengthPercent);
      // Calculate the segment normalised left and right vectors
      // The grass should face the grassFwdDir
      float3 widthDir;
      if (i == 0.0) {
        widthDir = normalize(cross(float3(0,1,0), grassFwdDir));
      }
      else {
        widthDir = normalize(cross(bladeSegment, grassFwdDir));
      }
      // Calculate blade left and right in local spaces
      float3 bladeLeft = bladeSegment + widthDir * halfWidth;
      float3 bladeRight = bladeSegment - widthDir * halfWidth;
      // Emits the vertex
      float4 color = lerp(float4(130,190,64,255) / 255, float4(181,233,97,255) / 255, fullLengthPercent);
      outputStream.Append(setupVertex(position + bladeLeft , color));
      outputStream.Append(setupVertex(position + bladeRight, color));
    }
    // Calculate tip position
    outputStream.Append(setupVertex(position + calcSegmentVector(position, normal, rotationMatrix, fullBladeLength, 1), float4(198,242,104,255) / 255));
    outputStream.RestartStrip();
  }
}
```

## Fragment Shader

```hlsl
fixed4 fragmentShader (GeometryOut fragIn) : SV_Target
{
  float4 fragOut = fragIn.color;
  return fragOut;
}
```

## Results

<blog-img src="/images/projects/grass/ball.png"></blog-img>
