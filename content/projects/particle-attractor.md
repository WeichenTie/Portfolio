---
title: "Particle Attractor"
thumbnail: "/images/projects/particle2d/thumbnail.webp"
description: "Particle simulation using vertex transformations in GLSL where you can click and drag around to make particles follow your cursor."
technologies: ["GLSL", "WebGL"]
assets: "/images/projects/portfolio"
showcased: false
source: "https://github.com/WeichenTie/ParticleAttractor"
demo: "https://weichentie.github.io/ParticleAttractor/"
---

# {{title}}

## Project Description

Particle attractor was an experiement aimed at understanding the basics of GPGPU in webGL. Because webGL2.0 does not support compute shaders, there were 2 primary methods of implementing this being, ping pong vertex transform, and ping pong textures. The simplest for this task is to use the vertex transform feedback which allows me to capture primitives generated by the vertex shader and record that data into buffer object. This allows me to keep the post transform state and render it to the screen on each frame.

## Technologies Used

<BlogTechnologies :tags="technologies"></BlogTechnologies>

## Planning

As this project is fairly simple, there are only a few steps to get the desired result.

1. Setup rendering engine.
2. Generate particles.
3. Initiate buffers.
4. Create shader program.
5. Create render loop.

## Setting Up the Rendering Engine.

I am using an extremely simple, hand written rendering engine that provides minimal abstraction over the shader programs and buffer objects. You can check it out in this project's repository.

## Generating Particles.

The great thing about the GPU is that it can process hundreds of thousands of vertices in parallel which means we can handle much more particles than on the CPU.

```ts
// We first generate a set of x and y coordinates for each particle
function generateParticles(count: number) {
  let particles = [];
  for (let i = 0; i < count; i++) {
    particles.push(Math.random() * width, Math.random() * height); // x // [!code highlight]
    particles.push(Math.random(), Math.random()); // y // [!code highlight]
  }
  return particles;
}
```

## Initiating Buffers.

Now we initiate all the buffers for this rendering engine.

```ts
// ...
this.VAO1 = new VAO(this.gl);
this.VAO2 = new VAO(this.gl);
this.VBO1 = new VBO(
  this.gl,
  generatePoints(this.numPoints),
  this.gl.DYNAMIC_DRAW,
);
this.VBO2 = new VBO(
  this.gl,
  generatePoints(this.numPoints),
  this.gl.DYNAMIC_DRAW,
);
this.TF1 = createTransformFeedback(this.gl, this.VBO1);
this.TF2 = createTransformFeedback(this.gl, this.VBO2);

// Set how data is arranged in the vertex buffer objects
const attribLayout = new VAOAttribLayout();
// Store position x and y
attribLayout.addAttrib(2, this.gl.FLOAT, false);
// Store velocity vx and vy
attribLayout.addAttrib(2, this.gl.FLOAT, false);

this.VAO1.addAttribute(this.VBO1, attribLayout);
this.VAO2.addAttribute(this.VBO2, attribLayout);
// ...
```

Notice how there is 2 VAO, VBO and TF buffers. This is what allows us to ping pong between the current state and the next state.

In other words, buffer A will first be used to calculate the next position which is then stored to buffer B. They are then swapped so that buffer B is used to calculate the next position which is stored in buffer A and so on.

## Programming the shader

For the shader, we

```glsl
#version 300 es
layout(location = 0) in vec2 a_OldPosition;
layout(location = 1) in vec2 a_OldVelocity;

uniform mat4 u_MVP; // model view projection matrix
uniform vec2 u_MousePosition;
uniform int u_MouseDown;

out vec2 v_NewPosition;
out vec2 v_NewVelocity;

// Returns the direction vector from particle to mouse
vec2 particleToMouse() {
    return normalize(u_MousePosition - a_OldPosition);
}
vec2 calcNewVelocity() {
    vec2 vel = vec2(0,0);
    // Accelerate the particle to mouse if
    // mouse left is pressed down.
    if (u_MouseDown == 1) {
        vel = a_OldVelocity + particleToMouse();
    }
    return vel;
}

void main() {
    v_NewVelocity = calcNewVelocity();
    v_NewPosition = a_OldPosition + v_NewVelocity;

    gl_Position = u_MVP * vec4(a_OldPosition, 0, 1);
    gl_PointSize = 1.0;
}
```

## Results
